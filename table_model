"""
This module contains classes for creating and interacting with a model-view table system, including an abstract table model, sort proxy filter model, and one or more table views. It allows table data, objects, and operations to be housed within a single class. Data currently need to be in the form of a list of column names, a list of lists containing row data, and a list of dictionaries containing details about the table columns (e.g. specified column width).

To do: Add option to format data and columns from a pandas dataframe; Add context menu building; Add editability
"""


from PySide2.QtWidgets import QTableView, QAbstractItemView, QSizePolicy, QMenu
from PySide2.QtCore import QAbstractTableModel, Qt, QSortFilterProxyModel


class Table:
    def __init__(self, name, parent=None, pandas=None, columns=[], data=[[]], info=None):
        self.name = name
        self.parent = parent
        self.info = info  # format: {"Label": "Column name to show", "Width": 50 "Type": "int, str, float, etc."}
        self.columns = self.columns_from_pandas(pandas) if pandas else columns
        self.data = self.data_from_pandas(pandas) if pandas else data
        self.model = TableModel(self)
        self.proxy_model = ProxyModel(self)
        self.tables = {}

    def add_table(self, name):
        self.tables[name] = TableView(self, name, self.proxy_model)

    def table_view(self, name):
        return self.tables[name]

    def add_record(self, record):
        self.data.append(record)
        self.refresh()

    def delete_record(self, i):
        self.data.pop(i)
        self.refresh()

    def refresh(self):
        self.model.beginResetModel()
        self.model.endResetModel()


class TableModel(QAbstractTableModel):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent

    def data(self, index, role):
        row = index.row()
        column = index.column()

        if role in [Qt.DisplayRole, Qt.EditRole]:
            column_name = self.parent.columns[column]
            if self.parent.info[column_name]["Type"] == "int":
                return int(self.parent.data[row][column])
            elif self.parent.info[column_name]["Type"] == "float":
                return float(self.parent.data[row][column])
            return str(self.parent.data[row][column])
        return None

    def setData(self, index, value, role):
        if role == Qt.EditRole:
            row = index.row()
            column = index.column()
            self.parent.data[row][column] = value
            return True
        return False

    def headerData(self, section, orientation, role):
        if role == Qt.DisplayRole:
            if orientation == Qt.Horizontal:
                column_name = self.parent.columns[section]
                return self.parent.info[column_name]["Label"]
        return None

    def rowCount(self, parent=None):
        return len(self.parent.data)

    def columnCount(self, parent=None):
        return len(self.parent.columns)

    def flags(self, index):
        return Qt.ItemIsEnabled | Qt.ItemIsSelectable


class ProxyModel(QSortFilterProxyModel):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.setSourceModel(self.parent.model)

    def filterAcceptsRow(self, source_row, source_parent):
        return True


class TableView(QTableView):
    def __init__(self, parent, name, model):
        super().__init__()
        self.parent = parent
        self.name = name
        self.setup()
        self.setModel(model)
        self.setSortingEnabled(True)
        self.set_widths()
        self.fit_rows()

    def setup(self):
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setHorizontalScrollMode(QAbstractItemView.ScrollPerPixel)
        self.horizontalHeader().setStretchLastSection(True)
        self.setAlternatingRowColors(True)
        self.setShowGrid(False)

    def set_widths(self):
        for i, column in enumerate(self.parent.columns):
            width = self.parent.info[column]["Width"]
            self.setColumnWidth(i, width)

    def fit_rows(self):
        for row in range(self.parent.model.rowCount()):
            self.resizeRowToContents(row)

    def contextMenuEvent(self, event):
        index = self.indexAt(event.pos())
        row = self.parent.proxy_model.mapToSource(index).row()
        column = self.parent.proxy_model.mapToSource(index).column()
        column_name = self.parent.columns[column]
        context_menu = QMenu(self)
        menu_items = {}
